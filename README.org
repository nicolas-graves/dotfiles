

* Dotfiles
** Why ?

I discovered system crafting / configuration thanks to [[https://larbs.xyz/][LARBS]] and fell into the rabbithole of system configuration for long-term efficiency reasons. I was happy with Arch, suffered from its lack of portability and reproducibility when I had some issues with my computer.

This repository encompass all my computers' configuration. Thanks to [[https://git.sr.ht/~abcdw/rde][Andrew Tropin's RDE]] and GNU Guix, the configuration is clean, small and simple (final goal: circa. 1k lines). It shouldn't be tedious to maintain your own dotfiles!

The code relies on hidden / private data, and won't work if deployed as such. However, the code follows a modular structure, making it simple to cherry-pick snippets. This code is licensed under GPLv3+, although the license isn't provided in the repo.

*** RDE

RDE is a developers and power user friendly GNU/Linux distribution, based on GNU Guix.

**** Principles

More detailed description can be found in the [[https://trop.in/rde/manual#Principles][manual]].
***** Main
- Ergonomic :: Sane keybindings, good contrast, readable fonts.
- Reproducible :: Setup can be easily replicated.
- Hackable :: Easy to throw out or modify any part of setup.
- Stateless :: All state must be explicit and syncable or temporary.
***** Secondary
- Lightweight and battery efficient :: wayland, fast native apps.
- Offline :: most of workflows and apps should work without network.
- Attention-friendly :: minimal use of notification and other distractive things.

**** Differences of this config

The code is a direct use of rde system. Here are the main differences :
- using evil-mode for emacs and sway.
- emacs' configuration is quite similar to David Wilson's former dotfiles

** Usage

This repo has been optimized for use as dotfiles // whole system configuration. It cannot be used as a channel. Instead, you can copy some configuration parts. Contribute them back to RDE when you feel you made an improvement!

The main file, =config= is very clear and modular (modules are imported close to where their functions and variables are used). This way, the repo only acts as a user and active testing ground for contributions to the other channels it relies on.

Every useful command is kept in the main =Makefile=.

*** Channels

Guix supports the concept of [[https://guix.gnu.org/manual/en/html_node/Channels.html#Channels][channels]] which contain Guix package definitions that can be installed on your machine.  Aside from the =%default-channels= list, I also use the [[https://gitlab.com/nonguix/nonguix][Nonguix]] channel to install packages that aren't included with Guix by default like the non-free Linux kernel, as well as [[https://git.sr.ht/~abcdw/rde][Andrew Tropin's RDE]].

The generation of =channels= is temporarily included in the =make home= call. It relies on the function =channels-content=, with the optional abiblity to pin or freeze commits.

*** Updating guix home

=make home=

*** Updating guix system

=make system=

*** Debugging tips

Debugging =config= can be easier if we use the variable =GUIX_PACKAGE_PATH=, although it is not necessary. This is the reason why I switched from =config.scm= and =channels.scm= to =config= and =channels=, to avoid them being considered as modules while they are not.

Running =guix repl= on files can also help.

*** If a font package has been updated and causes issues

=make update-fonts=

*** Privacy without GnuPG

Disclaimer: This approach is not a standard, and relies on recent software (=openssh>8.3=, =git>2.34=). Also, doing away without GnuPG implies that a lot of functionnalities aside everyday use might not yet be available. See more comments below.

**** Manage your keys

This README does not indicate basic use of SSH (=ssh-keygen=...).

Thanks to the recent =git= and =ssh= developments, most asymmetric / public-key cryptography everyday use cases can work using only =ssh=, =git= and =age=, using only ssh keys. It thus gives the same unified approached to key management as GnuPG does, without its alleged user experience.

This way, you can rely on only having ssh keys and managing them manually. Several approaches are possible: using the standard =~/.ssh= folder, relying on a security-token and fido2 ssh hardware keys, or a personal mix of both.

***** TODO Use fido2 native keys.

Instead of managing your keys in a single directory, you can also use a security token. This example uses a yubikey 5C, but there are also cheaper security tokens.

Using this

Optionally, if you only plan to use your yubikey otherwise, you can disable other applications.

#+begin_src shell
ykman config usb -d OPENPGP
ykman config nfc -d OPENPGP
ykman config usb -d HSMAUTH
ykman config nfc -d HSMAUTH
ykman config usb -d OAUTH
ykman config nfc -d OAUTH
#+end_src

(It's possible I don't have all steps here).

You'll need to set a PIN for your Yubikey:
#+begin_src shell
ykman fido access change-pin
#+end_src

TODO Basic generation / resident keys.

#+begin_src shell
ssh-add -K
#+end_src

***** Backing up keys

If not using fido2 keys, you will need to save keys to a encrypted flash drive. For more information, see [[https://github.com/drduh/YubiKey-Guide#backup][here]] or [[https://bruun.xyz/20210714_gnupg.html][here.]]

If using fido2 keys, making a backup of the keys extracted with the command =ssh-keygen -K= will not be helpful for a backup, since the keys will only work if the yubikey is plugged in. You either need to use a backup security token with another secret for each key on your regular security token ; or do the same thing with a backup ssh key stored safely (in an encrypted flash drive for instance).

***** How I manage my keys

Here is my personal mix: I use a regular ssh key for both encryption and signing, and hardware keys for authenticating. The reason for this is that 1) even with a no-touch-policy, backing up such keys does not seem trivial ; and =age= does not yet implement hardware keys (though it seems doable) 2) I can authenticate using another device without having to migrate any SSH keys or config.

I thus need three normal SSH keys:
- one for signing
- one for encryption
- one for authentification backup

**** Sign
***** Sign

RDE provides a way to sign your work using an ssh key. Indicate the public key using the option =git-sign-key= of =feature-git= to sign your commits with git. See [[https://calebhearth.com/sign-git-with-ssh#github][here]] for more info.

To sign outside of git using ssh (e.g. for binaries or packages), use the following command:

#+begin_src shell
ssh-keygen -Y sign -n "file" -f /.ssh/id_ed25519_sk < "${file_to_sign}" > "${file_to_sign}.asc"
#+end_src

***** Verify

With =ssh=, there is no web of trust. Forges allow to publich public keys easily, but there is no simple way to acess all public keys that might be needed to authenticate something.

The difficulty for verifying huge projects is that there one needs to explicitely download all keys used to commit to check every commit, using the file =~/.ssh/allowed_signers=. See [[https://calebhearth.com/sign-git-with-ssh#github][here]] for more info.

**** Encrypt

=age= provides a simple tool to encrypt your files, emails and passwords. It has its own format, but also works with ssh keys (not hardware keys).

With RDE, you only have to provide the location of your private key file using the option =#:age-ssh-key=.

Using =age= instead of GnuPG implies quite a lot of changes, notably because it implies to replace the standard unix password manager =password-store= by its fork =pass-age= (named this way on guix).

**** Authenticate

SSH

*** Org Mode

**** Workflow Principles

***** Don't look at Org files to find the next task, use the agenda view
***** Ensure sufficient metadata on tasks for effective filtering
***** Keep a daily log of work being done
***** Set timers on tasks
Use =org-timer-set-timer= to set a countdown timer for a task based on the "effort" value I set on it.
***** Future ideas and objectives
****** Learning panel ?
- I should use org-roam to synthetize information and org-drill in order to batch learn things easily. Maybe also having a learning.org and a learning tab is good practice in order to planify more clearly how I intend to learn things.

****** Manage proper clocking
I have read the corresponding man page quickly, seems pretty simple, but how is the information used after that ?
****** Email integration
- haven't tested how this integration works for now, maybe as simple as an org-capture.
- Workfkow : mail inbox --> todo.org --> review every evening ?
- have read a blog post claiming that emacs wasn't necessarily good with a lot of big extensions (mu4e, elfeed), mail ?
****** Block time properly on 25 minutes blocks + 5 min break
- Maybe inquire into the pomodoro technique ?
  Or maybe it's just good straightforward when properly done ?
****** Objective : set a goal on how organized should you be in beginning of January.
**** Workflow States

I try to keep my set of workflow states simple so that I can filter on them easily:

- =TODO= - A task that should be done at some point
- =NEXT= - This task should be done next (in the Getting Things Done sense) Beware !
- =HOLD= - Waiting for someone else to be actionable again
- =DONE= - It's done!

I also make sure to set them up in the order I want =org-sort-entries= to sort them in when I use the =o= option upon invoking that command.

**** Tags

Tags are used to filter all tasks to find anything actionable in a particular context.  I use the =@home= and =@work= tags for explicit contexts and then the rest are used for filtering tasks for agenda views.

- =manage= - I'm the person responsible for setting the rythm for this task. People rely on you, it should be prioritized above others.
- =organize= - This task should in some time help to complete other tasks (faster or simply the case). To prioritize over unproductive tasks.
- =followup= - Someone is waiting on me to follow up or give feedback on this task, it should be prioritized above others
- =batch= - The task can be batched with others (low effort)

**** Agendas

My agenda configuration is a custom one.

It integrates three different org-agenda-custom-commands :
- =Agenda of the day= is a classic agenda with an integrated =Current tasks= part.
- =Overview= is a complete agenda with priorities and workflow states and tags proper discrimination.
- =Review= is a agenda with =Backlog= and unprioritized =TODO= states.

Currently still customizing my agenda to match my expected use, I'll try to migrate it to rde later.

**** Note-taking

***** TODO Roam

This small description of a possible workflow with org-roam note-taking is highly inspired by [[https://jethrokuan.github.io/org-roam-guide/][Jethro Kuan's Org Roam guide]]. It's modified to fit RDE.

***** TODO Bibliography

*** Flatpak

The rationale for using flatpak is that some very popular applications are not present on GNU Guix. I'm trying to keep minimal dependencies on flatpak packages.

I'm using Ferdi to minimize the need to install various packages for discord, slack & co. And to keep configuration somewhere, although this time not in my dotfiles. Ferdi has had a few issues in the last couple of months, but seems to be online working again.

Proprietary apps and apps that use non-GTK, non-Qt toolkits are often limited to X11-only, which means they require =Xwayland= in order to work in a Wayland session. Hence the ~(xwayland enable)~ option in Sway configuration.

Some settings to add on wayland include ~--socket=wayland~ and ~--enable-features=UseOzonePlatform --ozone-platform=wayland~ (if the app is based on Electron).

In any way, we can imagine flatpak apps to be put in a wrapper to avoid repeat actions, when essential to a workflow. Maybe a hint for a future contribution ?

** System Installation

Here's a guide for how I install my RDE systems on a computer.  This process is extremely simplified, and implies you start with an already configured RDE system. If you need to start from scratch or bootstrap, you might want to take a look at the [[https://guix.gnu.org/manual/en/html_node/System-Installation.html][official installation guide]] or the [[https://wiki.systemcrafters.cc/guix/nonguix-installation-guide][Systems Crafters nonguix installation guide]] on how to do it.

*** Building the Installation Image

You need to create a slightly larger install image to ensure you have enough headroom for temporary file create and "no free space" errors.
The installation image can be built with this command in the ~dotfiles~ directory:

#+begin_src sh
GUILE_LOAD_PATH=./ RDE_TARGET=live-install guix system image ./config --image-size=7G
#+end_src

*NOTE:* It can take an hour or more for this to complete, so be patient...

Once the build is complete, Guix will print out the path to the disk image file that was created.  You can now write the installation image to a USB stick using =dd=:

#+begin_src sh
sudo dd if=/gnu/store/{sha256}-disk-image of=/dev/sdX bs=1M status=progress
#+end_src

*** Installing Guix

With the newly "burned" installation image, boot from the USB drive and choose "Install using the shell based process."

**** Setting up WiFi

The procedure counselled in the System Crafters wiki is quite a hassle and often fails. This was a reason to get rid of =connman= and use =NetworkManager= in the configuration, even though the former is lighter. Wifi configuration simply becomes :

#+begin_src sh
rfkill unblock all
nmtui
#+end_src

**** Setting Up Partitions

Steps to setup partitions are inspired by the ~etc/install.sh~ script from akagi.

Since we're installing on a ThinkPad with UEFI, follow the [[https://guix.gnu.org/manual/en/guix.html#Disk-Partitioning][instructions in the Guix manual]] for disk partitioning.  The short of it is that you need to use =fdisk= to create a partition in your free space:

#+begin_src sh
fdisk /dev/sda
#+end_src

Once you have your Linux root partition set up, you can make file-systems and enable LUKS to encrypt that partition by running the following commands (=enc= is an arbitrary label but is used in =make btrfs= so respect the label):

#+begin_src sh
mkfs.vfat -F32 /dev/<EFI partition>
mkswap /dev/<SWAP partition>
cryptsetup luksFormat /dev/<root partition>
cryptsetup open --type luks /dev/<root partition> enc
mkfs.btrfs /dev/mapper/enc
#+end_src

The remaining configuration is summarized in the simple script =make btrfs=. This script creates btrfs subvolumes =root=, =boot=, =home=, =store=, =log= and =data=. Once subvolumes are created, it mounts the root filesystem from =enc= device, and then mount all =btrfs= subvolumes.

Finally, make sure to mount your EFI partition to =/mnt/boot= so that the installer can install the bootloader. Make also sure to swapon your swap partition.

#+begin_src sh
mkdir -p /mnt/boot/efi
mount /dev/<EFI partition> /mnt/boot/efi
swapon /dev/<SWAP partition>
#+end_src

Now your EFI and encrypted root filesystems are mounted so you can proceed with system installation. You must now set up the installation environment using =herd=:

#+begin_src sh
herd start cow-store /mnt
#+end_src

**** Initial System Installation

The system configuration and sources are already packaged in the live-image created with =make image=. TODO possibly a small bug due to ssl verification failures, unexplained for now.

The initial system configuration is then simplified and basically comes down to:

#+begin_src sh
guix pull -C /etc/channels
hash guix
#+end_src

The pull operation may take a while depending on how recently the installation USB image has been generated.

Once your channels are set up, you will need to tweak your configuration to reflect the partition UUIDs and labels for the system that you are installing.  To figure out the UUID of your encrypted root partition, you can use the following command:

#+begin_src sh
cryptsetup luksUUID /dev/<root partition>
#+end_src

#+begin_quote

**TIP:** To make it easier to copy the UUID into your config file, you can switch to another tty using =Ctrl-Alt-F4= and press =Enter= to get to another root prompt.  You can then switch back and forth between the previous TTY on =F3=.

#+end_quote

You then need to enter your file-system information in the variable =devices= in the file =config=, which will premanently store this information. I use the hardware product name as a host-name for later robust configuration. Now you can initialize your system using the following command:

#+begin_src sh
guix system -L ~/.dotfiles/.config/guix/systems init path/to/config /mnt
#+end_src

This could take a while, so make sure your laptop is plugged in and let it run.  If you see any errors during installation, don't fret, you can usually resume from where you left off because your Guix store will have any packages that were already installed.

**** Initial System Setup

Congrats!  You now have a new Guix system installed, reboot now to complete the initial setup of your user account.

The first thing you'll want to do when you land at the login prompt is login as =root= and immediately change the =root= and user passwords using =passwd= (there isn't a root password by default!):

#+begin_src sh

  passwd             # Set passwd for 'root'
  passwd <username>  # Set password for your user account (no angle brackets)

#+end_src

Now log into your user account and clone your dotfiles repository, which is self-contained. Verify that the file-system configuration is accurate and tangle the =config.org= file. It will setup your =channels= file, so you can run =guix pull= to sync in the new channel. You can run =make system= and =make home= to configure your system and home environement according to your RDE configuration.

* Roadmap

** Own configuration

*** TODO Migrate LARBS scripts
delete old and unused scripts, find a way through emacs if possible.

**** TODO Create small emacs package to replicate menumount and menuumount functionaliy

https://raw.githubusercontent.com/LukeSmithxyz/voidrice/master/.local/bin/dmenumount
https://raw.githubusercontent.com/LukeSmithxyz/voidrice/master/.local/bin/dmenuumount

**** TODO Create small emacs package for power-menu

Previously used sysact :
https://paste.sr.ht/blob/aff8a4ca310abdae72c7d89d8aed9a78defba90f

**** TODO Perfect configuration for linkhandler and menuhandler former functionality
The functionality is present in emacs between =ffap-menu=, =link-hint= and =embark-open-externally=, but RDE doesn't seem to integrate it this well.

The solution probably comes with iterative use and configuration tweaking.

**** TODO waybar mail icon like sb-mailbox
Only the content of sb-mailbox would have to be completely rewritten.

**** TODO waybar vnstat module like sb-nettraf
Maybe with less frequent updates (10 seconds or so).


*** TODO find a solution for GnuPG
decided to swith to age, but not all features are working properly.

*** TODO Setup OVH email aliases
*** TODO Make a smart use of the sway scratchpad for specific emacsclient frames.
https://www.ryanjframe.com/blog/daily-logs-and-the-sway-scratchpad/

*** TODO Switch keyboard layout to programmer-beop
 Might be quite difficult to configure, here are the snippets I worked on :

 #+begin_src scheme
(use-modules (guix packages) (guix download) (guix git-download))

(define-public programmer-beop
  (let ((commit "402305021b7fbf825aa4ea8381f4c5ae9a5ed81f"))
    (origin
      (method git-fetch)
      (uri (git-reference
            (url "https://github.com/luxcem/programmer-beop")
            (commit commit)))
      (sha256
       (base32 "1y968pd3ynjngvwr1zkcwkvhkwblzs3isdak12zqzvgl1krdhqhv")))))

(define-public programmer-beop-image
  (origin
    (method url-fetch)
    (uri "https://luxcem.github.io/images/programmer_beop/prbeop.png")
    (sha256
     (base32 "10dzfwm75b7p3jk0i6hi3wkpjyfbj9jsx78zxzmm0cippphnpzw9"))))
 #+end_src

*** TODO vterm evil-mode integration

#+begin_src sh
setopt autocd		# Automatically cd into typed directory.

# vi mode
bindkey -v
export KEYTIMEOUT=1

# Use vim keys in tab complete menu:
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char

# Edit line in vim with ctrl-e:
autoload edit-command-line; zle -N edit-command-line
bindkey '^e' edit-command-line

# Search through history
#bindkey -s '^h' 'exec "$(fzf < ~/.cache/zsh/uniq_history)"\n'
#+end_src

*** TODO mpv evil integration

previous input.conf of mpv

#+begin_src sh
l seek 5
h seek -5
j seek -60
k seek 60
S cycle sub
#+end_src


*** Emacs

Some later improvements I might add to my rde configuration :
- need to check for geiser-guile-load-path ? doesn't seem to work that well.
- learn to use and configure eglot
- customize font sizes in org-mode by relying on daviwil's implementation ?
- When possible, allow calendar sync based on daviwil's implementation ?
- Reminders (through org-wild-notifier ?)
- =org-present= when preparing for presentations.
- flycheck only works with eglot, and not clear with which languages they work.
- check all Emacs Development packages (=elgot=, =flycheck=, =python=, =web-mode=)
- add feature for calendar =calfw=


*** Abandoned for now

- pam-gnupg (some things in the git directory, but won't implement it myself).
- system connection-services allowing to keep track of all connections as a part of a pass database, and re-inject them again. may be wortk once there's a guile-gpgme library allowing to parse passwords without being root when launched from cli. see the commit log, the complete service is there.

** Contribute back to RDE

The final goal would be to only rely on rde features.

- [ ] some heavy changes related to keyboards and window manager configuration.
- [ ] migrate the most part of the emacs features configuration.
  - [ ] emacs-evil (FIXME lacks modus-vivendi cursor compatibility)
  - [ ] emacs-saving
  - [ ] emacs-flycheck
  - [ ] emacs-web-mode
  - [ ] emacs-dired-hacks (ready?)
  - [ ] emacs-org-babel
  - [ ] emacs-python
  - [ ] emacs-eval-in-repl

** Changelog
- 2022-09-04: moved from config.org to config.scm for minimalism. Keeping the idea of modularity with pages and modules placed where they are needed. no need to tangle anymore.
- 2022-09-10: .guixchannel only exports the packages folder, to avoid strange errors / unuseful exports. edited README accordingly.
- 2022-09-11: moving away from being a channel : isn't useful. The goal of this repo is not to create an alternative to RDE, but instead to rely on it and provide a simple, sound and complete RDE config example. Other people shouldn't take this repo as a channel, and packages used can be included in the distro anyway, so being a channel only adds complexity.
