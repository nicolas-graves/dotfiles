

* Dotfiles
** Why ?

I discovered system crafting / configuration thanks to [[https://larbs.xyz/][LARBS]] / [[https://archlinux.org/][Archlinux]] and fell into the rabbithole of system configuration, mainly for long-term efficiency reasons. I was happy with Arch, but then had some issues with my computer, and found that portability and reproducibility is quite hard on Arch.

I discovered GNU Guix thanks to David Wilson and started to configure my system, based on [[https://github.com/daviwil/dotfiles][David Wilson's]] and [[https://git.sr.ht/~krevedkokun/dotfiles][krevedkokun's dotfiles]], and on [[https://larbs.xyz/][LARBS' scripts]]. I've finally migrated it under [[https://git.sr.ht/~abcdw/rde][Andrew Tropin's RDE]].

The code relies on hidden data, and won't work if deployed as such. However, the code is mainly written in literate org-babel programming. It allows for clearer distinction between ideas and code, thus facilitating the reading and cherry-picking of snippets.

*** RDE

RDE is a developers and power user friendly GNU/Linux distribution, based on GNU Guix.

**** Principles

More detailed description can be found in the [[https://trop.in/rde/manual#Principles][manual]].
***** Main
- Ergonomic :: Sane keybindings, good contrast, readable fonts.
- Reproducible :: Setup can be easily replicated.
- Hackable :: Easy to throw out or modify any part of setup.
- Stateless :: All state must be explicit and syncable or temporary.
***** Secondary
- Lightweight and battery efficient :: wayland, fast native apps.
- Offline :: most of workflows and apps should work without network.
- Attention-friendly :: minimal use of notification and other
  distractive things.

**** Differences of this config

The code is a direct use of rde's system. Here are the main differences :
- using evil-mode for emacs and sway.
- added a system-connections service to system to also deploy wifi data (unused for now)
- emacs' configuration is quite similar to David Wilson's former dotfiles
- rbw ?
- a whole server configuration, included in dotfiles (cuirass, git, rsync for now).

** Usage

Every useful command is kept in the main =Makefile=.

*** Tangling files
Since I keep all of my important configuration files in Org Mode code blocks, I often have to ensure that the real configuration files are kept up to date.

=make tangle=

*** Syncing

When I want to sync my dotfiles repo into my local clone which likely has uncommitted changes, I run =make udpate=.  This script first makes sure that all Org files are saved in a running Emacs instance and then stashes everything before pulling the latest changes from =origin=.  After pulling, the stash is popped and then the script verifies there are no merge conflicts from the stash before proceeding.  If there are no conflicts, =make tangle= is run, otherwise I'll fix the merge conflicts manually and run =make tangle= myself.

*** Updating home

=make home=

*** Updating system

=make system=

*** Checking for error in tangled files

=make check=

*** If a font package has been updated and causes issues

=make update-fonts=

** System Installation

Here's a guide for how I install my GNU Guix systems from scratch.  This process is simplified because I've already prepared a reusable system configuration so you might need to do extra work if you end up following this for your own system install.

*** Building the Installation Image

Since I use modern Thinkpads, I have to use the non-free kernel and firmware blobs from the [[https://gitlab.com/nonguix/nonguix][nonguix]] channel.  After cloning the repo, the installation image can be built with this command:

#+begin_src sh

  # Create a slightly larger install image to have some headroom
  # for temporary file creation and avoid "no space free" errors
  GUILE_LOAD_PATH=./ guix system image ./system/install.scm --image-size=6G

#+end_src

*NOTE:* It can take an hour or more for this to complete, so be patient...

Once the build is complete, Guix will print out the path to the disk image file that was created.  You can now write the installation image to a USB stick using =dd=:

#+begin_src sh

  sudo dd if=/gnu/store/{sha256}-disk-image of=/dev/sdX status=progress

#+end_src

*** Installing Guix

TODO Adapt the process to my new installation image.
With the newly "burned" installation image, boot from the USB drive and choose "Install using the shell based process."

**** Setting up WiFi

Use an editor (or =echo=) to create a new file called =wifi.conf= to store the wifi configuration.  Make sure to set =ssid= to the name of your wifi access point and =psk= to the passphrase for your wifi.  You may also need to change the =key_mgmt= parameter depending on the type of authentication your wifi router supports ([[https://wiki.archlinux.org/index.php/Wpa_supplicant#Configuration][some examples]] on Arch Wiki).

#+begin_src

  network={
    ssid="ssid-name"
    key_mgmt=WPA-PSK
    psk="unencrypted passphrase"
  }

#+end_src

First, run the following commands to unblock the wifi card, determine its device name, and connect using the device name you received from =ifconfig -a=.  In my case it's =wlp4s0= so I run the command like so:

#+begin_src sh

  rfkill unblock all
  ifconfig -a
  wpa_supplicant -c wifi.conf -i wlp4s0 -B

#+end_src

#+begin_quote

*NOTE:* If for any reason running =wpa_supplicant= fails, make sure to kill any background instances of it before trying to run it again because the old instances will block new runs from working.  This wasted a couple hours of my time the first time I tried installing Guix!

#+end_quote

The last step to set up networking is to run =dhclient= to turn on DNS for your wifi connection:

#+begin_src sh

  dhclient -v wlp4s0

#+end_src

**** Setting Up Partitions

Steps to setup partitions are inspired by the ~etc/install.sh~ script from akagi.

Since we're installing on a ThinkPad with UEFI, follow the [[https://guix.gnu.org/manual/en/guix.html#Disk-Partitioning][instructions in the Guix manual]] for disk partitioning.  The short of it is that you need to use =fdisk= to create a partition in your free space:

#+begin_src sh

  fdisk /dev/nvme0n1

#+end_src

Once you have your Linux root partition set up, you can enable LUKS to encrypt that partition by running the following commands (where =/dev/nvme0n1p3= is your root partition and =enc= is an arbitrary label you'd like to use for it):

#+begin_src sh

  cryptsetup luksFormat /dev/nvme0n1p3
  cryptsetup open --type luks /dev/nvme0n1p5 enc
  mkfs.btrfs -L enc /dev/mapper/enc
  mount LABEL=enc /mnt
  # or mount -t btrfs /dev/mapper/enc /mnt

#+end_src

Create btrfs subvolumes you use if not already done.

#+begin_src

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/store
btrfs subvolume create /mnt/data
btrfs subvolume create /mnt/log

#+end_src

Now that subvolumes are created, mount the root filesystem from =enc= device. Then mount all =btrfs= subvolumes.

#+begin_src

umount /mnt
mount -o subvol=root /dev/mapper/enc /mnt

cd /mnt
mkdir home
mkdir gnu/store -p
mkdir data
mkdir var/log -p
mkdir boot

mount -o compress=zstd,discard,space_cache=v2,subvol=home /dev/mapper/guix home
mount -o compress=zstd,discard,space_cache=v2,subvol=store /dev/mapper/guix gnu/store
mount -o compress=zstd,discard,space_cache=v2,subvol=data /dev/mapper/guix data
mount -o compress=zstd,discard,space_cache=v2,subvol=log /dev/mapper/guix var/log
mount -o compress=zstd,discard,space_cache=v2,subvol=boot /dev/mapper/guix boot

#+end_src

Finally, make sure to mount your EFI partition to =/mnt/boot= so that the installer can install the bootloader.  The Guix installation instructions obscure this step slightly so it's easy to miss:

#+begin_src sh

  mkdir -p /mnt/boot/efi
  mount /dev/<EFI partition> /mnt/boot/efi

#+end_src

Now your EFI and encrypted root filesystems are mounted so you can proceed with system installation.  You must now set up the installation environment using =herd=:

#+begin_src sh

  herd start cow-store /mnt

#+end_src

**** Initial System Installation

If you've got a system configuration prepared already, you can use =git= to pull it down into the current directory (the one you're already in, not =/mnt=):

#+begin_src sh

  git clone https://github.com/daviwil/dotfiles

#+end_src

One important step before you attempt system installation is to set up the =nonguix= channel so that the system can be installed from it.  Once you've cloned your dotfiles repo, you can place your =channels.scm= file into the root user's =.config/guix= path and then run =guix pull= to activate it:

#+begin_src sh

  mkdir -p ~/.config/guix
  cp dotfiles/guix/channels.scm ~/.config/guix
  guix pull
  hash guix  # This is necessary to ensure the updated profile path is active!

#+end_src

The pull operation may take a while depending on how recently you generated your installation USB image (if packages in the main Guix repository have been updated since then).

Once your channels are set up, you will need to tweak your configuration to reflect the partition UUIDs and labels for the system that you are installing.  To figure out the UUID of your encrypted root partition, you can use the following command:

#+begin_src sh

  cryptsetup luksUUID /dev/<root partition>

#+end_src

#+begin_quote

**TIP:** To make it easier to copy the UUID into your config file, you can switch to another tty using =Ctrl-Alt-F4= and press =Enter= to get to another root prompt.  You can then switch back and forth between the previous TTY on =F3=.

#+end_quote

Now you can initialize your system using the following command:

#+begin_src sh

  guix system -L ~/.dotfiles/.config/guix/systems init path/to/config.scm /mnt

#+end_src

This could take a while, so make sure your laptop is plugged in and let it run.  If you see any errors during installation, don't fret, you can usually resume from where you left off because your Guix store will have any packages that were already installed.

**** Initial System Setup

Congrats!  You now have a new Guix system installed, reboot now to complete the initial setup of your user account.

The first thing you'll want to do when you land at the login prompt is login as =root= and immediately change the =root= and user passwords using =passwd= (there isn't a root password by default!):

#+begin_src sh

  passwd             # Set passwd for 'root'
  passwd <username>  # Set password for your user account (no angle brackets)

#+end_src

Now log into your user account and clone your dotfiles repository.

Since we used the =nonguix= channel to install the non-free Linux kernel, we'll need to make sure that channel is configured in our user account so that we have access to those packages the next time we =guix pull=.  At the moment I just symlink the Guix config folder from my =.dotfiles= to =~/.config/guix=:

#+begin_src sh

  ln -sf ~/.dotfiles/guix ~/.config/guix

#+end_src

Verify that your =channels.scm= file is in the target path (=~/.config/guix/channels.scm=) and then run =guix pull= to sync in the new channel.

Now you can install the packages that you want to use for day-to-day activities.  I separate different types of packages into individual manifest files and manage them with my =activate-profiles= script:

#+begin_src sh

  activate-profiles desktop emacs

#+end_src

Now the packages for these manifests will be installed and usable.  They can be updated in the future by using the =update-profiles= script.

* Roadmap

** Own configuration

- [ ] need to find a way to centralize shortcuts management.
- [ ] moving to GnuPG : erase ssh-keys configuration to move it to gpg.
- [ ] migrate old and useful LARBS scripts (so they work on the system) / delete others.
- [ ] pam-gnupg works but starts the gpg-agent before shepherd. need to write a
  pam_shepherd module to pick the pwd directly from login ?
  - Andrew Tropin actually planned to do that.

** Contribute back to RDE

The final goal would be to only rely on rde features.

- [ ] some heavy changes related to keyboards and window manager configuration.
- [-] migrate the most part of the emacs features configuration.
  - [ ] emacs-evil (FIXME lacks modus-vivendi cursor compatibility)
  - [ ] emacs-ux (clarify where)
  - [ ] emacs-openwith (NO: replace by proper-functionning consult-file-externally function)
  - [ ] emacs-elfeed (ready?)
  - [ ] emacs-deft (ready?)
  - [ ] emacs-lispy
  - [ ] emacs-flycheck
  - [-] emacs-yasnippet (proposed)
  - [ ] emacs-web-mode
  - [ ] emacs-yaml-mode
  - [ ] emacs-org-clocking (merge into emacs-org and emacs-org-agenda configs)
  - [ ] emacs-parinfer
  - [-] emacs-geiser (to propose)
  - [-] emacs-guix-development (to propose)
  - [ ] emacs-dired-hacks
  - [ ] emacs-org-babel
  - [ ] emacs-org-latex
  - [ ] emacs-python
  - [ ] emacs-my-org-agenda
  - [-] emacs-my-org-roam (waiting for org-roam-ui package to be merged upstream)
  - [ ] emacs-org-roam-bibtex
  - [ ] emacs-eval-in-repl
  - [ ] emacs-origami-el
